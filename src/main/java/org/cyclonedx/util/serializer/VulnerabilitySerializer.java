/*
 * This file is part of CycloneDX Core (Java).
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 * Copyright (c) OWASP Foundation. All Rights Reserved.
 */
package org.cyclonedx.util.serializer;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.databind.SerializerProvider;
import com.fasterxml.jackson.databind.ser.std.StdSerializer;
import com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator;
import org.apache.commons.collections4.CollectionUtils;
import org.apache.commons.lang3.StringUtils;
import org.cyclonedx.Version;
import org.cyclonedx.model.Component;
import org.cyclonedx.model.Tool;
import org.cyclonedx.model.vulnerability.Vulnerability;
import org.cyclonedx.model.metadata.ToolInformation;
import org.cyclonedx.model.Property;

import static org.cyclonedx.util.serializer.SerializerUtils.shouldSerializeField;

public class VulnerabilitySerializer
    extends StdSerializer<Vulnerability>
{
  private final boolean isXml;

  private final Version version;

  public VulnerabilitySerializer(final boolean isXml, final Version version) {
    this(null, isXml, version);
  }

  public VulnerabilitySerializer(final Class<Vulnerability> t, final boolean isXml, final Version version) {
    super(t);
    this.isXml = isXml;
    this.version = version;
  }

  @Override
  public void serialize(Vulnerability vulnerability, JsonGenerator jsonGenerator, SerializerProvider serializerProvider)
      throws IOException
  {
    if (isXml && jsonGenerator instanceof ToXmlGenerator) {
      ToXmlGenerator xmlGenerator = (ToXmlGenerator) jsonGenerator;
      createVulnerabilityInfo(vulnerability, xmlGenerator, serializerProvider);
    }
    else {
      createVulnerabilityInfo(vulnerability, jsonGenerator, serializerProvider);
    }
  }

  private void createVulnerabilityInfo(
      final Vulnerability vulnerability,
      final JsonGenerator jsonGenerator,
      SerializerProvider serializerProvider)
      throws IOException
  {
    jsonGenerator.writeStartObject();

    if (StringUtils.isNotEmpty(vulnerability.getBomRef()) && shouldSerializeField(vulnerability, version, "bom-ref")) {
      if (isXml && jsonGenerator instanceof ToXmlGenerator) {
        ToXmlGenerator xmlGenerator = (ToXmlGenerator) jsonGenerator;
        xmlGenerator.setNextIsAttribute(true);
        jsonGenerator.writeStringField("bom-ref", vulnerability.getBomRef());
        xmlGenerator.setNextIsAttribute(false);
      } else {
        jsonGenerator.writeStringField("bom-ref", vulnerability.getBomRef());
      }
    }

    if (StringUtils.isNotEmpty(vulnerability.getId()) && shouldSerializeField(vulnerability, version, "id")) {
      jsonGenerator.writeStringField("id", vulnerability.getId());
    }

    if (vulnerability.getSource() != null && shouldSerializeField(vulnerability, version, "source")) {
      jsonGenerator.writeObjectField("source", vulnerability.getSource());
    }

    if (CollectionUtils.isNotEmpty(vulnerability.getReferences()) && shouldSerializeField(vulnerability, version, "references")) {
      if (isXml) {
        ToXmlGenerator xmlGenerator = (ToXmlGenerator) jsonGenerator;
        writeArrayFieldXML(vulnerability.getReferences(), xmlGenerator, "reference");
      }
      else {
        jsonGenerator.writeObjectField("references", vulnerability.getReferences());
      }
    }

    if (CollectionUtils.isNotEmpty(vulnerability.getRatings()) && shouldSerializeField(vulnerability, version, "ratings")) {
      if (isXml) {
        ToXmlGenerator xmlGenerator = (ToXmlGenerator) jsonGenerator;
        writeArrayFieldXML(vulnerability.getRatings(), xmlGenerator, "rating");
      }
      else {
        jsonGenerator.writeObjectField("ratings", vulnerability.getRatings());
      }
    }

    if (CollectionUtils.isNotEmpty(vulnerability.getCwes()) && shouldSerializeField(vulnerability, version, "cwes")) {
      if (isXml) {
        ToXmlGenerator xmlGenerator = (ToXmlGenerator) jsonGenerator;
        writeArrayFieldXML(vulnerability.getCwes(), xmlGenerator, "cwe");
      }
      else {
        jsonGenerator.writeObjectField("cwes", vulnerability.getCwes());
      }
    }

    if (StringUtils.isNotEmpty(vulnerability.getDescription()) && shouldSerializeField(vulnerability, version, "description")) {
      jsonGenerator.writeStringField("description", vulnerability.getDescription());
    }

    if (StringUtils.isNotEmpty(vulnerability.getDetail()) && shouldSerializeField(vulnerability, version, "detail")) {
      jsonGenerator.writeStringField("detail", vulnerability.getDetail());
    }

    if (StringUtils.isNotEmpty(vulnerability.getRecommendation()) && shouldSerializeField(vulnerability, version, "recommendation")) {
      jsonGenerator.writeStringField("recommendation", vulnerability.getRecommendation());
    }

    if (StringUtils.isNotEmpty(vulnerability.getWorkaround()) && shouldSerializeField(vulnerability, version, "workaround")) {
      jsonGenerator.writeStringField("workaround", vulnerability.getWorkaround());
    }

    if (vulnerability.getProofOfConcept() != null && shouldSerializeField(vulnerability, version, "proofOfConcept")) {
      jsonGenerator.writeObjectField("proofOfConcept", vulnerability.getProofOfConcept());
    }

    if (CollectionUtils.isNotEmpty(vulnerability.getAdvisories()) && shouldSerializeField(vulnerability, version, "advisories")) {
      if (isXml) {
        ToXmlGenerator xmlGenerator = (ToXmlGenerator) jsonGenerator;
        writeArrayFieldXML(vulnerability.getAdvisories(), xmlGenerator, "advisories", "advisory");
      }
      else {
        jsonGenerator.writeObjectField("advisories", vulnerability.getAdvisories());
      }
    }

    if (vulnerability.getCreated() != null && shouldSerializeField(vulnerability, version, "created")) {
      jsonGenerator.writeFieldName("created");
      new CustomDateSerializer().serialize(vulnerability.getCreated(), jsonGenerator, serializerProvider);
    }

    if (vulnerability.getPublished() != null && shouldSerializeField(vulnerability, version, "published")) {
      jsonGenerator.writeFieldName("published");
      new CustomDateSerializer().serialize(vulnerability.getPublished(), jsonGenerator, serializerProvider);
    }

    if (vulnerability.getUpdated() != null && shouldSerializeField(vulnerability, version, "updated")) {
      jsonGenerator.writeFieldName("updated");
      new CustomDateSerializer().serialize(vulnerability.getUpdated(), jsonGenerator, serializerProvider);
    }

    if (vulnerability.getRejected() != null && shouldSerializeField(vulnerability, version, "rejected")) {
      jsonGenerator.writeFieldName("rejected");
      new CustomDateSerializer().serialize(vulnerability.getRejected(), jsonGenerator, serializerProvider);
    }

    if (vulnerability.getCredits() != null && shouldSerializeField(vulnerability, version, "credits")) {
      jsonGenerator.writeObjectField("credits", vulnerability.getCredits());
    }

    // Tools - version-aware serialization
    parseTools(vulnerability, jsonGenerator);

    if (vulnerability.getAnalysis() != null && shouldSerializeField(vulnerability, version, "analysis")) {
      jsonGenerator.writeObjectField("analysis", vulnerability.getAnalysis());
    }

    if (CollectionUtils.isNotEmpty(vulnerability.getAffects()) && shouldSerializeField(vulnerability, version, "affects")) {
      if (isXml) {
        ToXmlGenerator xmlGenerator = (ToXmlGenerator) jsonGenerator;
        writeArrayFieldXML(vulnerability.getAffects(), xmlGenerator, "affects", "target");
      }
      else {
        jsonGenerator.writeObjectField("affects", vulnerability.getAffects());
      }
    }

    if (CollectionUtils.isNotEmpty(vulnerability.getProperties()) && shouldSerializeField(vulnerability, version, "properties")) {
      if (isXml) {
        ToXmlGenerator xmlGenerator = (ToXmlGenerator) jsonGenerator;
        xmlGenerator.writeFieldName("properties");
        xmlGenerator.writeStartObject();

        for (Property property : vulnerability.getProperties()) {
          xmlGenerator.writeObjectField("property", property);
        }
        xmlGenerator.writeEndObject();
      }
      else {
        jsonGenerator.writeObjectField("properties", vulnerability.getProperties());
      }
    }

    jsonGenerator.writeEndObject();
  }

  private void parseTools(Vulnerability vulnerability, JsonGenerator jsonGenerator) throws IOException {
    // For v1.5+, check if we have the new ToolInformation format first (priority over deprecated)
    if (version.getVersion() >= Version.VERSION_15.getVersion()) {
      ToolInformation choice = vulnerability.getToolChoice();
      if (choice != null && (CollectionUtils.isNotEmpty(choice.getComponents()) || CollectionUtils.isNotEmpty(choice.getServices()))) {
        // Use the new format
        jsonGenerator.writeFieldName("tools");
        jsonGenerator.writeStartObject();
        if (isXml && jsonGenerator instanceof ToXmlGenerator) {
          if (CollectionUtils.isNotEmpty(choice.getComponents())) {
            writeArrayFieldXML(choice.getComponents(), (ToXmlGenerator) jsonGenerator, "component");
          }
          if (CollectionUtils.isNotEmpty(choice.getServices())) {
            writeArrayFieldXML(choice.getServices(), (ToXmlGenerator) jsonGenerator, "service");
          }
        }
        else {
          if (CollectionUtils.isNotEmpty(choice.getComponents())) {
            writeArrayFieldJSON(jsonGenerator, "components", choice.getComponents());
          }
          if (CollectionUtils.isNotEmpty(choice.getServices())) {
            writeArrayFieldJSON(jsonGenerator, "services", choice.getServices());
          }
        }
        jsonGenerator.writeEndObject();
        return;
      }
    }

    // Fall back to deprecated tools format if present
    if (CollectionUtils.isNotEmpty(vulnerability.getTools())) {
      if (isXml && jsonGenerator instanceof ToXmlGenerator) {
        writeArrayFieldXML(vulnerability.getTools(), (ToXmlGenerator) jsonGenerator, "tool");
      }
      else {
        writeArrayFieldJSON(jsonGenerator, "tools", vulnerability.getTools());
      }
    }
  }

  private <T> void writeArrayFieldJSON(JsonGenerator jsonGenerator, String fieldName, List<T> items)
      throws IOException
  {
    if (items != null) {
      jsonGenerator.writeArrayFieldStart(fieldName);
      for (T item : items) {
        jsonGenerator.writeObject(item);
      }
      jsonGenerator.writeEndArray();
    }
  }

  private <T> void writeArrayFieldXML(List<T> items, ToXmlGenerator xmlGenerator, String fieldName) throws IOException {
    writeArrayFieldXML(items, xmlGenerator, fieldName + "s", fieldName);
  }

  private <T> void writeArrayFieldXML(List<T> items, ToXmlGenerator xmlGenerator, String wrapperName, String elementName) throws IOException {
    if (CollectionUtils.isNotEmpty(items)) {
      xmlGenerator.writeFieldName(wrapperName);
      xmlGenerator.writeStartObject();
      for (T item : items) {
        xmlGenerator.writeFieldName(elementName);
        xmlGenerator.writeObject(item);
      }
      xmlGenerator.writeEndObject();
    }
  }

  @Override
  public Class<Vulnerability> handledType() {
    return Vulnerability.class;
  }
}
